<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Adaptive Brick Ball Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #gameCanvas {
            border: 2px solid #444;
            background: #000;
            display: block;
        }
        
        #gameCanvas.playing {
            cursor: none;
        }
        
        #gameInfo {
            margin-top: 10px;
            display: flex;
            gap: 30px;
            font-size: 18px;
        }
        
        #instructions {
            margin-top: 10px;
            text-align: center;
            color: #aaa;
        }
        
        .power-up-timer {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            margin: 5px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <h1>Intelligent Adaptive Brick Ball</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="gameInfo">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Accuracy: <span id="accuracy">0%</span></div>
    </div>
    
    <div id="powerUps"></div>
    
    <div id="instructions">
        Use ← → arrow keys or mouse to move paddle | SPACE to pause | Click to start
    </div>

    <script>
        // Game Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game State
        let gameState = 'menu'; // menu, playing, paused, gameOver, levelComplete
        let animationId;
        
        // Game Objects
        const game = {
            score: 0,
            lives: 3,
            level: 1,
            lastTime: 0,
            keys: {},
            mouse: { x: 400, y: 500 }
        };
        
        // Player Performance Metrics (for AI)
        const playerMetrics = {
            ballsLost: 0,
            bricksHit: 0,
            totalBallBounces: 0,
            paddleHits: 0,
            missedBalls: 0,
            timeSpentOnLevel: 0,
            consecutiveDeaths: 0,
            currentAccuracy: 0,
            levelStartTime: Date.now(),
            skillLevel: 'average', // struggling, average, skilled
            needsHelp: false,
            recentPerformance: [], // Track last 10 ball interactions
            avgReactionTime: 0,
            paddleMissDistance: 0 // How far off paddle was when ball was missed
        };
        
        // AI Performance Analysis System
        const aiAnalysis = {
            updateInterval: 1000, // Update every second
            lastUpdate: Date.now(),
            
            analyzePerformance() {
                const now = Date.now();
                playerMetrics.timeSpentOnLevel = now - playerMetrics.levelStartTime;
                
                // Calculate current accuracy
                if (playerMetrics.totalBallBounces > 0) {
                    playerMetrics.currentAccuracy = Math.round((playerMetrics.bricksHit / playerMetrics.totalBallBounces) * 100);
                }
                
                // Determine skill level based on multiple factors
                this.determineSkillLevel();
                
                // Check if player needs help
                this.checkNeedsHelp();
                
                // Update performance history
                this.updatePerformanceHistory();
            },
            
            determineSkillLevel() {
                const accuracy = playerMetrics.currentAccuracy;
                const consecutiveDeaths = playerMetrics.consecutiveDeaths;
                const timeOnLevel = playerMetrics.timeSpentOnLevel / 1000; // Convert to seconds
                const ballsLostRate = playerMetrics.ballsLost / Math.max(1, timeOnLevel / 30); // Balls lost per 30 seconds
                
                // Struggling indicators
                if (accuracy < 30 || consecutiveDeaths >= 3 || ballsLostRate > 2) {
                    playerMetrics.skillLevel = 'struggling';
                } 
                // Skilled indicators
                else if (accuracy > 60 && consecutiveDeaths === 0 && ballsLostRate < 0.5) {
                    playerMetrics.skillLevel = 'skilled';
                }
                // Average (default)
                else {
                    playerMetrics.skillLevel = 'average';
                }
            },
            
            checkNeedsHelp() {
                const struggling = playerMetrics.skillLevel === 'struggling';
                const longTimeOnLevel = playerMetrics.timeSpentOnLevel > 120000; // 2 minutes
                const lowProgress = playerMetrics.bricksHit < 10 && playerMetrics.timeSpentOnLevel > 60000; // Less than 10 bricks in 1 minute
                
                playerMetrics.needsHelp = struggling || longTimeOnLevel || lowProgress;
            },
            
            updatePerformanceHistory() {
                // Track recent performance for trend analysis
                const currentPerformance = {
                    timestamp: Date.now(),
                    accuracy: playerMetrics.currentAccuracy,
                    consecutiveDeaths: playerMetrics.consecutiveDeaths,
                    skillLevel: playerMetrics.skillLevel
                };
                
                playerMetrics.recentPerformance.push(currentPerformance);
                
                // Keep only last 10 entries
                if (playerMetrics.recentPerformance.length > 10) {
                    playerMetrics.recentPerformance.shift();
                }
            },
            
            trackPaddleMiss(ballX, paddleX, paddleWidth) {
                // Calculate how far the ball was from the paddle center when missed
                const paddleCenter = paddleX + paddleWidth / 2;
                const missDistance = Math.abs(ballX - paddleCenter);
                
                // Update average miss distance (for AI assistance calibration)
                if (playerMetrics.paddleMissDistance === 0) {
                    playerMetrics.paddleMissDistance = missDistance;
                } else {
                    playerMetrics.paddleMissDistance = (playerMetrics.paddleMissDistance + missDistance) / 2;
                }
            },
            
            getAssistanceLevel() {
                if (playerMetrics.skillLevel === 'struggling') {
                    return 'active'; // Noticeable help
                } else if (playerMetrics.skillLevel === 'average' && playerMetrics.needsHelp) {
                    return 'subtle'; // Minor help
                } else {
                    return 'none'; // No help needed
                }
            },
            
            shouldIncreasePowerUpRate() {
                return playerMetrics.skillLevel === 'struggling' || 
                       (playerMetrics.consecutiveDeaths >= 2 && playerMetrics.currentAccuracy < 40);
            },
            
            shouldDecreasePowerUpRate() {
                return playerMetrics.skillLevel === 'skilled' && playerMetrics.currentAccuracy > 70;
            }
        };
        
        // Multi-ball system
        const balls = []; // Additional balls for multi-ball power-up
        
        // Paddle Object
        const paddle = {
            x: 350,
            y: 550,
            width: 100,
            height: 15,
            speed: 8,
            normalWidth: 100,
            usingMouse: false,
            
            update() {
                // Arrow key controls (only if not using mouse)
                if (!this.usingMouse) {
                    if (game.keys['ArrowLeft'] && this.x > 0) {
                        this.x -= this.speed;
                    }
                    if (game.keys['ArrowRight'] && this.x < canvas.width - this.width) {
                        this.x += this.speed;
                    }
                }
                
                // Mouse controls (only when mouse is actively being used)
                if (this.usingMouse && game.mouse.x >= 0 && game.mouse.x <= canvas.width) {
                    this.x = Math.max(0, Math.min(canvas.width - this.width, game.mouse.x - this.width / 2));
                }
            },
            
            draw() {
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Add a slight gradient effect
                ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.fillRect(this.x, this.y, this.width, 3);
            },
            
            reset() {
                this.x = 350;
                this.width = this.normalWidth;
            }
        };
        
        // Ball Object
        const ball = {
            x: 400,
            y: 530,
            radius: 8,
            dx: 0,
            dy: 0,
            speed: 5,
            normalSpeed: 5,
            onPaddle: true,
            
            update() {
                if (this.onPaddle) {
                    // Ball follows paddle when on paddle
                    this.x = paddle.x + paddle.width / 2;
                    this.y = paddle.y - this.radius;
                    return;
                }
                
                // Move ball
                this.x += this.dx;
                this.y += this.dy;
                
                // Wall collisions
                if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) {
                    this.dx = -this.dx;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                
                if (this.y - this.radius <= 0) {
                    this.dy = -this.dy;
                    this.y = this.radius;
                }
                
                // Paddle collision
                if (this.y + this.radius >= paddle.y && 
                    this.y - this.radius <= paddle.y + paddle.height &&
                    this.x >= paddle.x && 
                    this.x <= paddle.x + paddle.width) {
                    
                    // Calculate bounce angle based on where ball hits paddle
                    const hitPos = (this.x - paddle.x) / paddle.width;
                    const bounceAngle = (hitPos - 0.5) * Math.PI * 0.6; // Max 54 degrees
                    
                    this.dx = Math.sin(bounceAngle) * this.speed;
                    this.dy = -Math.cos(bounceAngle) * this.speed;
                    this.y = paddle.y - this.radius;
                    
                    // Track paddle hits for AI
                    playerMetrics.paddleHits++;
                    playerMetrics.totalBallBounces++;
                }
                
                // Ball falls off bottom
                if (this.y > canvas.height) {
                    this.respawn();
                }
            },
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                
                // Add glow effect
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            },
            
            launch() {
                if (this.onPaddle) {
                    this.onPaddle = false;
                    this.dx = (Math.random() - 0.5) * 4;
                    this.dy = -this.speed;
                }
            },
            
            respawn() {
                // Only lose a life if ALL balls are gone (main ball + multi-balls)
                if (balls.length === 0) {
                    // No other balls in play, lose a life
                    game.lives--;
                    playerMetrics.ballsLost++;
                    playerMetrics.consecutiveDeaths++;
                    playerMetrics.missedBalls++;
                    
                    // Track paddle miss for AI analysis
                    aiAnalysis.trackPaddleMiss(this.x, paddle.x, paddle.width);
                    
                    if (game.lives <= 0) {
                        gameState = 'gameOver';
                        // Show cursor when game ends
                        canvas.classList.remove('playing');
                        return;
                    }
                    
                    // Brief pause before respawn
                    gameState = 'ballLost';
                    setTimeout(() => {
                        if (game.lives > 0) {
                            this.onPaddle = true;
                            this.x = paddle.x + paddle.width / 2;
                            this.y = paddle.y - this.radius;
                            this.dx = 0;
                            this.dy = 0;
                            gameState = 'playing';
                        }
                    }, 1000);
                } else {
                    // Other balls still in play, just remove this ball
                    this.onPaddle = true;
                    this.x = paddle.x + paddle.width / 2;
                    this.y = paddle.y - this.radius;
                    this.dx = 0;
                    this.dy = 0;
                }
            },
            
            reset() {
                this.onPaddle = true;
                this.x = paddle.x + paddle.width / 2;
                this.y = paddle.y - this.radius;
                this.dx = 0;
                this.dy = 0;
                this.speed = this.normalSpeed;
            }
        };
        
        // Brick System
        const bricks = [];
        const brickConfig = {
            rows: 6,
            cols: 10,
            width: 75,
            height: 20,
            padding: 5,
            offsetTop: 60,
            offsetLeft: 37.5,
            types: [
                { color: '#ff4444', hits: 1, points: 10, name: 'red' },
                { color: '#ff8844', hits: 1, points: 20, name: 'orange' },
                { color: '#ffff44', hits: 2, points: 30, name: 'yellow' },
                { color: '#44ff44', hits: 2, points: 40, name: 'green' }
            ]
        };
        
        function createBricks() {
            bricks.length = 0;
            
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const x = col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft;
                    const y = row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop;
                    
                    // Determine brick type based on row
                    let typeIndex;
                    if (row < 2) typeIndex = 0; // Red bricks (top 2 rows)
                    else if (row < 4) typeIndex = 1; // Orange bricks (next 2 rows)
                    else if (row < 5) typeIndex = 2; // Yellow bricks (1 row)
                    else typeIndex = 3; // Green bricks (bottom row)
                    
                    const brickType = brickConfig.types[typeIndex];
                    
                    bricks.push({
                        x: x,
                        y: y,
                        width: brickConfig.width,
                        height: brickConfig.height,
                        hits: brickType.hits,
                        maxHits: brickType.hits,
                        points: brickType.points,
                        color: brickType.color,
                        name: brickType.name,
                        destroyed: false
                    });
                }
            }
        }
        
        function drawBricks() {
            bricks.forEach(brick => {
                if (brick.destroyed) return;
                
                // Calculate color intensity based on remaining hits
                const intensity = brick.hits / brick.maxHits;
                let color = brick.color;
                
                if (intensity < 1) {
                    // Darken damaged bricks
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);
                    
                    color = `rgb(${Math.floor(r * intensity)}, ${Math.floor(g * intensity)}, ${Math.floor(b * intensity)})`;
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                
                // Add border
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                
                // Add highlight for 3D effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(brick.x, brick.y, brick.width, 3);
            });
        }
        
        // Power-up System
        const powerUps = [];
        const activePowerUps = [];
        
        const powerUpTypes = {
            widePaddle: {
                name: 'Wide Paddle',
                color: '#4444ff',
                letter: 'W',
                duration: 15000,
                effect: () => {
                    paddle.width = paddle.normalWidth * 1.5;
                },
                reset: () => {
                    paddle.width = paddle.normalWidth;
                }
            },
            multiBall: {
                name: 'Multi-ball',
                color: '#ff44ff',
                letter: 'M',
                duration: 0, // Permanent until balls are lost
                effect: () => {
                    // Split current ball into 3 balls
                    if (!ball.onPaddle) {
                        const originalDx = ball.dx;
                        const originalDy = ball.dy;
                        
                        // Create two additional balls
                        balls.push({
                            x: ball.x,
                            y: ball.y,
                            radius: ball.radius,
                            dx: originalDx * 0.7 + 2,
                            dy: originalDy,
                            speed: ball.speed,
                            onPaddle: false
                        });
                        
                        balls.push({
                            x: ball.x,
                            y: ball.y,
                            radius: ball.radius,
                            dx: originalDx * 0.7 - 2,
                            dy: originalDy,
                            speed: ball.speed,
                            onPaddle: false
                        });
                        
                        // Modify original ball
                        ball.dx = originalDx;
                        ball.dy = originalDy;
                    }
                }
            },
            slowBall: {
                name: 'Slow Ball',
                color: '#44ff44',
                letter: 'S',
                duration: 20000,
                effect: () => {
                    ball.speed = ball.normalSpeed * 0.7;
                    balls.forEach(b => b.speed = ball.speed);
                },
                reset: () => {
                    ball.speed = ball.normalSpeed;
                    balls.forEach(b => b.speed = ball.normalSpeed);
                }
            }
        };
        
        function createPowerUp(x, y) {
            const types = Object.keys(powerUpTypes);
            const randomType = types[Math.floor(Math.random() * types.length)];
            
            powerUps.push({
                x: x - 15,
                y: y,
                width: 30,
                height: 20,
                dy: 2,
                type: randomType,
                config: powerUpTypes[randomType]
            });
        }
        
        function checkBrickCollisions() {
            for (let i = 0; i < bricks.length; i++) {
                const brick = bricks[i];
                if (brick.destroyed) continue;
                
                // Check if ball intersects with brick
                if (ball.x + ball.radius > brick.x &&
                    ball.x - ball.radius < brick.x + brick.width &&
                    ball.y + ball.radius > brick.y &&
                    ball.y - ball.radius < brick.y + brick.height) {
                    
                    // Determine collision side
                    const ballCenterX = ball.x;
                    const ballCenterY = ball.y;
                    const brickCenterX = brick.x + brick.width / 2;
                    const brickCenterY = brick.y + brick.height / 2;
                    
                    const deltaX = ballCenterX - brickCenterX;
                    const deltaY = ballCenterY - brickCenterY;
                    
                    const intersectX = Math.abs(deltaX) - (brick.width / 2 + ball.radius);
                    const intersectY = Math.abs(deltaY) - (brick.height / 2 + ball.radius);
                    
                    // Bounce ball based on collision side
                    if (intersectX > intersectY) {
                        ball.dx = -ball.dx;
                    } else {
                        ball.dy = -ball.dy;
                    }
                    
                    // Damage brick
                    brick.hits--;
                    playerMetrics.bricksHit++;
                    playerMetrics.totalBallBounces++;
                    
                    if (brick.hits <= 0) {
                        brick.destroyed = true;
                        game.score += brick.points;
                        
                        // Create particle effect
                        createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color);
                        
                        // Dynamic power-up drop rate based on player performance
                        let dropRate = 0.15; // Base 15% chance
                        
                        if (aiAnalysis.shouldIncreasePowerUpRate()) {
                            dropRate = 0.25; // 25% for struggling players
                        } else if (aiAnalysis.shouldDecreasePowerUpRate()) {
                            dropRate = 0.10; // 10% for skilled players
                        }
                        
                        if (Math.random() < dropRate) {
                            createPowerUp(brick.x + brick.width / 2, brick.y + brick.height / 2);
                        }
                        
                        // Reset consecutive deaths on successful hit
                        playerMetrics.consecutiveDeaths = 0;
                    }
                    
                    // Check if level is complete
                    if (bricks.every(b => b.destroyed)) {
                        gameState = 'levelComplete';
                        setTimeout(() => {
                            nextLevel();
                        }, 2000);
                    }
                    
                    break; // Only handle one collision per frame
                }
            }
        }
        
        function checkBrickCollisionsForBall(ballObj) {
            for (let i = 0; i < bricks.length; i++) {
                const brick = bricks[i];
                if (brick.destroyed) continue;
                
                if (ballObj.x + ballObj.radius > brick.x &&
                    ballObj.x - ballObj.radius < brick.x + brick.width &&
                    ballObj.y + ballObj.radius > brick.y &&
                    ballObj.y - ballObj.radius < brick.y + brick.height) {
                    
                    const ballCenterX = ballObj.x;
                    const ballCenterY = ballObj.y;
                    const brickCenterX = brick.x + brick.width / 2;
                    const brickCenterY = brick.y + brick.height / 2;
                    
                    const deltaX = ballCenterX - brickCenterX;
                    const deltaY = ballCenterY - brickCenterY;
                    
                    const intersectX = Math.abs(deltaX) - (brick.width / 2 + ballObj.radius);
                    const intersectY = Math.abs(deltaY) - (brick.height / 2 + ballObj.radius);
                    
                    if (intersectX > intersectY) {
                        ballObj.dx = -ballObj.dx;
                    } else {
                        ballObj.dy = -ballObj.dy;
                    }
                    
                    brick.hits--;
                    playerMetrics.bricksHit++;
                    playerMetrics.totalBallBounces++;
                    
                    if (brick.hits <= 0) {
                        brick.destroyed = true;
                        game.score += brick.points;
                        
                        createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color);
                        
                        // Dynamic power-up drop rate based on player performance
                        let dropRate = 0.15; // Base 15% chance
                        
                        if (aiAnalysis.shouldIncreasePowerUpRate()) {
                            dropRate = 0.25; // 25% for struggling players
                        } else if (aiAnalysis.shouldDecreasePowerUpRate()) {
                            dropRate = 0.10; // 10% for skilled players
                        }
                        
                        if (Math.random() < dropRate) {
                            createPowerUp(brick.x + brick.width / 2, brick.y + brick.height / 2);
                        }
                        
                        playerMetrics.consecutiveDeaths = 0;
                    }
                    
                    if (bricks.every(b => b.destroyed)) {
                        gameState = 'levelComplete';
                        setTimeout(() => {
                            nextLevel();
                        }, 2000);
                    }
                    
                    break;
                }
            }
        }
        
        // Particle System for Visual Effects
        const particles = [];
        
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    color: color,
                    life: 30,
                    maxLife: 30
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.dy += 0.3; // Gravity
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
            });
        }
        
        function updatePowerUps() {
            // Update falling power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.dy;
                
                // Check collision with paddle
                if (powerUp.y + powerUp.height >= paddle.y &&
                    powerUp.y <= paddle.y + paddle.height &&
                    powerUp.x + powerUp.width >= paddle.x &&
                    powerUp.x <= paddle.x + paddle.width) {
                    
                    // Activate power-up
                    activatePowerUp(powerUp.type);
                    powerUps.splice(i, 1);
                    continue;
                }
                
                // Remove if off screen
                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                }
            }
            
            // Update active power-up timers
            for (let i = activePowerUps.length - 1; i >= 0; i--) {
                const activePowerUp = activePowerUps[i];
                activePowerUp.timeLeft -= 16; // Approximate frame time
                
                if (activePowerUp.timeLeft <= 0) {
                    // Reset power-up effect
                    if (activePowerUp.config.reset) {
                        activePowerUp.config.reset();
                    }
                    activePowerUps.splice(i, 1);
                }
            }
        }
        
        function drawPowerUps() {
            // Draw falling power-ups
            powerUps.forEach(powerUp => {
                ctx.fillStyle = powerUp.config.color;
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                
                // Draw letter
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(powerUp.config.letter, powerUp.x + powerUp.width / 2, powerUp.y + 14);
            });
        }
        
        function activatePowerUp(type) {
            const config = powerUpTypes[type];
            
            // Apply effect
            config.effect();
            
            // Add to active power-ups if it has a duration
            if (config.duration > 0) {
                // Remove existing power-up of same type
                for (let i = activePowerUps.length - 1; i >= 0; i--) {
                    if (activePowerUps[i].type === type) {
                        activePowerUps.splice(i, 1);
                        break;
                    }
                }
                
                activePowerUps.push({
                    type: type,
                    config: config,
                    timeLeft: config.duration
                });
            }
            
            updatePowerUpUI();
        }
        
        function updatePowerUpUI() {
            const powerUpDiv = document.getElementById('powerUps');
            powerUpDiv.innerHTML = '';
            
            activePowerUps.forEach(powerUp => {
                const timer = document.createElement('div');
                timer.className = 'power-up-timer';
                timer.style.backgroundColor = powerUp.config.color;
                timer.textContent = `${powerUp.config.name}: ${Math.ceil(powerUp.timeLeft / 1000)}s`;
                powerUpDiv.appendChild(timer);
            });
        }
        
        function updateMultiBalls() {
            for (let i = balls.length - 1; i >= 0; i--) {
                const extraBall = balls[i];
                
                // Move ball
                extraBall.x += extraBall.dx;
                extraBall.y += extraBall.dy;
                
                // Wall collisions
                if (extraBall.x - extraBall.radius <= 0 || extraBall.x + extraBall.radius >= canvas.width) {
                    extraBall.dx = -extraBall.dx;
                    extraBall.x = Math.max(extraBall.radius, Math.min(canvas.width - extraBall.radius, extraBall.x));
                }
                
                if (extraBall.y - extraBall.radius <= 0) {
                    extraBall.dy = -extraBall.dy;
                    extraBall.y = extraBall.radius;
                }
                
                // Paddle collision
                if (extraBall.y + extraBall.radius >= paddle.y && 
                    extraBall.y - extraBall.radius <= paddle.y + paddle.height &&
                    extraBall.x >= paddle.x && 
                    extraBall.x <= paddle.x + paddle.width) {
                    
                    const hitPos = (extraBall.x - paddle.x) / paddle.width;
                    const bounceAngle = (hitPos - 0.5) * Math.PI * 0.6;
                    
                    extraBall.dx = Math.sin(bounceAngle) * extraBall.speed;
                    extraBall.dy = -Math.cos(bounceAngle) * extraBall.speed;
                    extraBall.y = paddle.y - extraBall.radius;
                    
                    playerMetrics.paddleHits++;
                    playerMetrics.totalBallBounces++;
                }
                
                // Check brick collisions for extra balls
                checkBrickCollisionsForBall(extraBall);
                
                // Remove if falls off screen
                if (extraBall.y > canvas.height) {
                    balls.splice(i, 1);
                }
            }
        }
        
        function drawMultiBalls() {
            balls.forEach(extraBall => {
                ctx.beginPath();
                ctx.arc(extraBall.x, extraBall.y, extraBall.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }
        
        function nextLevel() {
            game.level++;
            createBricks();
            ball.reset();
            paddle.reset();
            
            // Slightly increase difficulty each level
            ball.normalSpeed += 0.2;
            ball.speed = ball.normalSpeed;
            
            // Increase paddle speed slightly too
            paddle.speed += 0.2;
            
            gameState = 'playing';
            playerMetrics.levelStartTime = Date.now();
            
            // Reset consecutive deaths for new level
            playerMetrics.consecutiveDeaths = 0;
        }
        
        // Event Listeners
        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
            
            // Switch to keyboard control when arrow keys are pressed
            if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                paddle.usingMouse = false;
            }
            
            // ENTER key launches ball when using keyboard controls
            if (e.code === 'Enter' && gameState === 'playing' && ball.onPaddle && !paddle.usingMouse) {
                e.preventDefault();
                ball.launch();
            }
            
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'playing') {
                    gameState = 'paused';
                } else if (gameState === 'paused') {
                    gameState = 'playing';
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouse.x = e.clientX - rect.left;
            game.mouse.y = e.clientY - rect.top;
            
            // Switch to mouse control when mouse moves
            if (gameState === 'playing') {
                paddle.usingMouse = true;
            }
        });
        
        canvas.addEventListener('click', (e) => {
            if (gameState === 'menu' || gameState === 'gameOver') {
                startGame();
            } else if (gameState === 'playing' && ball.onPaddle) {
                ball.launch();
            } else if (gameState === 'ballLost') {
                // Allow clicking during ball lost state to continue faster
                if (game.lives > 0) {
                    ball.onPaddle = true;
                    ball.x = paddle.x + paddle.width / 2;
                    ball.y = paddle.y - ball.radius;
                    ball.dx = 0;
                    ball.dy = 0;
                    gameState = 'playing';
                }
            }
        });
        
        // Game Functions
        function startGame() {
            gameState = 'playing';
            game.score = 0;
            game.lives = 3;
            game.level = 1;
            
            // Hide cursor when game starts
            canvas.classList.add('playing');
            
            // Reset objects to initial state
            paddle.reset();
            paddle.speed = 8; // Reset paddle speed
            ball.reset();
            ball.normalSpeed = 5; // Reset ball speed
            ball.speed = 5;
            createBricks();
            
            // Clear particles and power-ups
            particles.length = 0;
            powerUps.length = 0;
            balls.length = 0;
            activePowerUps.length = 0;
            updatePowerUpUI();
            
            // Reset metrics
            Object.keys(playerMetrics).forEach(key => {
                if (key !== 'levelStartTime' && key !== 'recentPerformance') {
                    if (key === 'skillLevel') {
                        playerMetrics[key] = 'average';
                    } else if (key === 'needsHelp') {
                        playerMetrics[key] = false;
                    } else {
                        playerMetrics[key] = 0;
                    }
                }
            });
            playerMetrics.levelStartTime = Date.now();
            playerMetrics.recentPerformance = [];
            aiAnalysis.lastUpdate = Date.now();
            
            updateUI();
        }
        
        function updateUI() {
            document.getElementById('score').textContent = game.score;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('level').textContent = game.level;
            
            // Calculate and display accuracy with AI skill level indicator
            const accuracy = playerMetrics.totalBallBounces > 0 ? 
                Math.round((playerMetrics.bricksHit / playerMetrics.totalBallBounces) * 100) : 0;
            
            let accuracyText = accuracy + '%';
            
            // Add skill level indicator (subtle visual feedback)
            if (playerMetrics.skillLevel === 'struggling') {
                accuracyText += ' 🔴'; // Red circle for struggling
            } else if (playerMetrics.skillLevel === 'skilled') {
                accuracyText += ' 🟢'; // Green circle for skilled
            } else {
                accuracyText += ' 🟡'; // Yellow circle for average
            }
            
            document.getElementById('accuracy').textContent = accuracyText;
            playerMetrics.currentAccuracy = accuracy;
        }
        
        function drawMenu() {
            // Show cursor in menu
            canvas.classList.remove('playing');
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BRICK BALL', canvas.width / 2, 200);
            
            ctx.font = '24px Arial';
            ctx.fillText('Intelligent Adaptive Gameplay', canvas.width / 2, 240);
            
            ctx.font = '18px Arial';
            ctx.fillText('Click to Start', canvas.width / 2, 350);
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText('The AI will adapt to help you succeed!', canvas.width / 2, 400);
        }
        
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, 200);
            
            ctx.font = '24px Arial';
            ctx.fillText(`Final Score: ${game.score}`, canvas.width / 2, 260);
            ctx.fillText(`Level Reached: ${game.level}`, canvas.width / 2, 290);
            ctx.fillText(`Accuracy: ${playerMetrics.currentAccuracy}%`, canvas.width / 2, 320);
            
            ctx.font = '16px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText(`Bricks Hit: ${playerMetrics.bricksHit} | Balls Lost: ${playerMetrics.ballsLost}`, canvas.width / 2, 360);
            
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            ctx.fillText('Click to Play Again', canvas.width / 2, 420);
        }
        
        function drawBallLost() {
            // Draw game objects (frozen)
            drawBricks();
            paddle.draw();
            drawParticles();
            
            // Draw ball lost message
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ff4444';
            ctx.font = '36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BALL LOST!', canvas.width / 2, canvas.height / 2 - 20);
            
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            ctx.fillText(`Lives Remaining: ${game.lives}`, canvas.width / 2, canvas.height / 2 + 20);
            
            if (game.lives > 0) {
                ctx.font = '14px Arial';
                ctx.fillStyle = '#aaa';
                ctx.fillText('Click to continue or wait...', canvas.width / 2, canvas.height / 2 + 50);
            }
        }
        
        function drawPaused() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            
            ctx.font = '18px Arial';
            ctx.fillText('Press SPACE to continue', canvas.width / 2, canvas.height / 2 + 40);
        }
        
        // Main Game Loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - game.lastTime;
            game.lastTime = currentTime;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'playing') {
                // Update game objects
                paddle.update();
                ball.update();
                updateMultiBalls();
                checkBrickCollisions();
                updatePowerUps();
                updateParticles();
                
                // Draw game objects
                drawBricks();
                paddle.draw();
                ball.draw();
                drawMultiBalls();
                drawPowerUps();
                drawParticles();
                
                // Update AI analysis
                if (Date.now() - aiAnalysis.lastUpdate > aiAnalysis.updateInterval) {
                    aiAnalysis.analyzePerformance();
                    aiAnalysis.lastUpdate = Date.now();
                }
                
                // Update UI
                updateUI();
                
            } else if (gameState === 'levelComplete') {
                // Draw game objects
                drawBricks();
                paddle.draw();
                ball.draw();
                drawParticles();
                
                // Draw level complete message
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2);
                
                ctx.font = '18px Arial';
                ctx.fillText('Get ready for the next level...', canvas.width / 2, canvas.height / 2 + 40);
                
            } else if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'gameOver') {
                drawGameOver();
            } else if (gameState === 'ballLost') {
                drawBallLost();
            } else if (gameState === 'paused') {
                // Draw game objects (frozen)
                drawBricks();
                paddle.draw();
                ball.draw();
                drawMultiBalls();
                drawPowerUps();
                drawParticles();
                drawPaused();
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        gameLoop(0);
    </script>
</body>
</html>
