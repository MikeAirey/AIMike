<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Adaptive Brick Ball Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #gameCanvas {
            border: 2px solid #444;
            background: #000;
            display: block;
        }
        
        #gameCanvas.playing {
            cursor: none;
        }
        
        #gameInfo {
            margin-top: 10px;
            display: flex;
            gap: 30px;
            font-size: 18px;
        }
        
        #instructions {
            margin-top: 10px;
            text-align: center;
            color: #aaa;
        }
        
        .power-up-timer {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 8px 12px;
            border-radius: 5px;
            margin: 5px;
            display: inline-block;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        /* Accessibility styles */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        #audioControls {
            margin-bottom: 10px;
        }
        
        #audioToggle {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid #444;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        #audioToggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        #audioToggle:focus {
            outline: 2px solid #4CAF50;
            outline-offset: 2px;
        }
        
        #gameCanvas:focus {
            outline: 3px solid #4CAF50;
            outline-offset: 2px;
        }
        
        /* Improve contrast for better accessibility */
        #instructions {
            color: #ccc;
            font-size: 16px;
        }
        
        #gameInfo {
            font-size: 20px;
            font-weight: bold;
        }
        
        /* Sprint Controls Styling */
        #sprintControls {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: center;
            max-width: 800px;
        }
        
        #sprintControls h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .control-group {
            margin: 10px 15px;
            display: inline-block;
            vertical-align: top;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }
        
        .control-group input {
            padding: 5px 8px;
            border-radius: 3px;
            border: 1px solid #444;
            background: #333;
            color: white;
            width: 80px;
            font-size: 14px;
        }
        
        .control-group input:focus {
            outline: 2px solid #4CAF50;
            outline-offset: 1px;
        }
        
        .control-buttons {
            margin-top: 15px;
        }
        
        .control-buttons button {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid #444;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 0 5px;
            transition: background-color 0.2s;
        }
        
        .control-buttons button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .control-buttons button:focus {
            outline: 2px solid #4CAF50;
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <h1>Intelligent Adaptive Brick Ball</h1>
    
    <!-- Screen reader announcements -->
    <div id="gameAnnouncements" aria-live="polite" aria-atomic="true" class="sr-only"></div>
    <div id="gameStatus" aria-live="assertive" aria-atomic="true" class="sr-only"></div>
    
    <!-- Audio controls -->
    <div id="audioControls">
        <button id="audioToggle" type="button" aria-pressed="true">üîä Sound: ON</button>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600" 
            role="application" 
            aria-label="Brick Ball Game - Use arrow keys to move paddle, space to pause, enter or click to launch ball"
            aria-describedby="gameInfo instructions"
            tabindex="0"></canvas>
    
    <div id="gameInfo" role="status" aria-live="polite">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Accuracy: <span id="accuracy">0%</span></div>
    </div>
    
    <div id="powerUps" aria-live="polite" aria-label="Active power-ups"></div>
    
    <div id="instructions">
        Use ‚Üê ‚Üí arrow keys or mouse to move paddle | SPACE to pause | ENTER or Click to launch ball/start game | SHIFT to sprint
    </div>
    
    <div id="sprintControls">
        <h3>Sprint Configuration</h3>
        <div class="control-group">
            <label for="accelerationPeriod">Acceleration Period (ms):</label>
            <input type="number" id="accelerationPeriod" value="500" min="100" max="2000" step="50">
        </div>
        <div class="control-group">
            <label for="defaultSpeed">Default Speed:</label>
            <input type="number" id="defaultSpeed" value="5" min="1" max="20" step="0.5">
        </div>
        <div class="control-group">
            <label for="topSpeed">Top Speed:</label>
            <input type="number" id="topSpeed" value="50" min="10" max="200" step="5">
        </div>
        <div class="control-buttons">
            <button id="applySprintConfig">Apply Settings</button>
            <button id="resetSprintConfig">Reset to Defaults</button>
        </div>
    </div>

    <script>
        // Game Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game State
        let gameState = 'menu'; // menu, playing, paused, gameOver, levelComplete
        let animationId;
        
        // Accessibility System
        const accessibility = {
            audioEnabled: true,
            audioContext: null,
            
            init() {
                // Initialize audio context on first user interaction
                document.addEventListener('click', this.initAudio.bind(this), { once: true });
                document.addEventListener('keydown', this.initAudio.bind(this), { once: true });
                
                // Setup audio toggle button
                const audioToggle = document.getElementById('audioToggle');
                audioToggle.addEventListener('click', this.toggleAudio.bind(this));
            },
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                    this.audioEnabled = false;
                }
            },
            
            toggleAudio() {
                this.audioEnabled = !this.audioEnabled;
                const button = document.getElementById('audioToggle');
                button.textContent = this.audioEnabled ? 'üîä Sound: ON' : 'üîá Sound: OFF';
                button.setAttribute('aria-pressed', this.audioEnabled.toString());
            },
            
            playSound(frequency, duration = 100, type = 'sine') {
                if (!this.audioEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration / 1000);
            },
            
            announce(message, priority = 'polite') {
                const element = priority === 'assertive' ? 
                    document.getElementById('gameStatus') : 
                    document.getElementById('gameAnnouncements');
                
                element.textContent = message;
                
                // Clear after a delay to allow for new announcements
                setTimeout(() => {
                    if (element.textContent === message) {
                        element.textContent = '';
                    }
                }, 3000);
            },
            
            announceGameState(state) {
                switch (state) {
                    case 'menu':
                        this.announce('Game menu. Click or press Enter to start playing.');
                        break;
                    case 'playing':
                        this.announce('Game started. Use arrow keys to move paddle.');
                        break;
                    case 'paused':
                        this.announce('Game paused. Press Space to continue.', 'assertive');
                        break;
                    case 'ballLost':
                        this.announce(`Ball lost! ${game.lives} lives remaining.`, 'assertive');
                        this.playSound(200, 300, 'sawtooth'); // Low warning sound
                        break;
                    case 'gameOver':
                        this.announce(`Game Over! Final score: ${game.score}. Level reached: ${game.level}.`, 'assertive');
                        this.playSound(150, 500, 'triangle'); // Game over sound
                        break;
                    case 'levelComplete':
                        this.announce(`Level ${game.level} complete! Advancing to next level.`);
                        this.playSound(800, 200); // Success sound
                        break;
                }
            },
            
            announcePowerUp(powerUpName) {
                this.announce(`Power-up collected: ${powerUpName}`);
                this.playSound(600, 150); // Power-up sound
            },
            
            announceBrickHit(brickColor, points) {
                // Only announce occasionally to avoid spam
                if (Math.random() < 0.1) {
                    this.announce(`${brickColor} brick hit for ${points} points`);
                }
                this.playSound(400 + (points * 5), 50); // Pitch varies with points
            },
            
            announcePaddleHit() {
                this.playSound(300, 50, 'square'); // Paddle hit sound
            },
            
            announceWallBounce() {
                this.playSound(250, 30, 'square'); // Wall bounce sound
            }
        };
        
        // Sprint Configuration System
        const sprintConfig = {
            accelerationPeriodMs: 500,
            defaultSpeed: 5,
            topSpeed: 50,
            
            // Calculate multiplier dynamically
            get speedMultiplier() {
                return this.topSpeed / this.defaultSpeed;
            }
        };
        
        // Sprint State Management
        const sprintState = {
            isActive: false,
            isAccelerating: false,
            isDecelerating: false,
            startTime: 0,
            ballStates: new Map(), // track each ball's original speed
            currentOscillator: null,
            audioUpdateTimer: null
        };
        
        // Sprint Audio Configuration
        const sprintAudio = {
            baseFrequency: 300,
            maxFrequency: 800,
            oscillatorType: 'sine',
            volume: 0.1,
            updateInterval: 50
        };
        
        // Game Objects
        const game = {
            score: 0,
            lives: 3,
            level: 1,
            lastTime: 0,
            keys: {},
            mouse: { x: 400, y: 500 }
        };
        
        // Player Performance Metrics (for AI)
        const playerMetrics = {
            ballsLost: 0,
            bricksHit: 0,
            totalBallBounces: 0,
            paddleHits: 0,
            missedBalls: 0,
            timeSpentOnLevel: 0,
            consecutiveDeaths: 0,
            currentAccuracy: 0,
            levelStartTime: Date.now(),
            skillLevel: 'average', // struggling, average, skilled
            needsHelp: false,
            recentPerformance: [], // Track last 10 ball interactions
            avgReactionTime: 0,
            paddleMissDistance: 0 // How far off paddle was when ball was missed
        };
        
        // AI Performance Analysis System
        const aiAnalysis = {
            updateInterval: 1000, // Update every second
            lastUpdate: Date.now(),
            
            analyzePerformance() {
                const now = Date.now();
                playerMetrics.timeSpentOnLevel = now - playerMetrics.levelStartTime;
                
                // Calculate current accuracy
                if (playerMetrics.totalBallBounces > 0) {
                    playerMetrics.currentAccuracy = Math.round((playerMetrics.bricksHit / playerMetrics.totalBallBounces) * 100);
                }
                
                // Determine skill level based on multiple factors
                this.determineSkillLevel();
                
                // Check if player needs help
                this.checkNeedsHelp();
                
                // Update performance history
                this.updatePerformanceHistory();
            },
            
            determineSkillLevel() {
                const accuracy = playerMetrics.currentAccuracy;
                const consecutiveDeaths = playerMetrics.consecutiveDeaths;
                const timeOnLevel = playerMetrics.timeSpentOnLevel / 1000; // Convert to seconds
                const ballsLostRate = playerMetrics.ballsLost / Math.max(1, timeOnLevel / 30); // Balls lost per 30 seconds
                
                // Struggling indicators
                if (accuracy < 30 || consecutiveDeaths >= 3 || ballsLostRate > 2) {
                    playerMetrics.skillLevel = 'struggling';
                } 
                // Skilled indicators
                else if (accuracy > 60 && consecutiveDeaths === 0 && ballsLostRate < 0.5) {
                    playerMetrics.skillLevel = 'skilled';
                }
                // Average (default)
                else {
                    playerMetrics.skillLevel = 'average';
                }
            },
            
            checkNeedsHelp() {
                const struggling = playerMetrics.skillLevel === 'struggling';
                const longTimeOnLevel = playerMetrics.timeSpentOnLevel > 120000; // 2 minutes
                const lowProgress = playerMetrics.bricksHit < 10 && playerMetrics.timeSpentOnLevel > 60000; // Less than 10 bricks in 1 minute
                
                playerMetrics.needsHelp = struggling || longTimeOnLevel || lowProgress;
            },
            
            updatePerformanceHistory() {
                // Track recent performance for trend analysis
                const currentPerformance = {
                    timestamp: Date.now(),
                    accuracy: playerMetrics.currentAccuracy,
                    consecutiveDeaths: playerMetrics.consecutiveDeaths,
                    skillLevel: playerMetrics.skillLevel
                };
                
                playerMetrics.recentPerformance.push(currentPerformance);
                
                // Keep only last 10 entries
                if (playerMetrics.recentPerformance.length > 10) {
                    playerMetrics.recentPerformance.shift();
                }
            },
            
            trackPaddleMiss(ballX, paddleX, paddleWidth) {
                // Calculate how far the ball was from the paddle center when missed
                const paddleCenter = paddleX + paddleWidth / 2;
                const missDistance = Math.abs(ballX - paddleCenter);
                
                // Update average miss distance (for AI assistance calibration)
                if (playerMetrics.paddleMissDistance === 0) {
                    playerMetrics.paddleMissDistance = missDistance;
                } else {
                    playerMetrics.paddleMissDistance = (playerMetrics.paddleMissDistance + missDistance) / 2;
                }
            },
            
            getAssistanceLevel() {
                if (playerMetrics.skillLevel === 'struggling') {
                    return 'active'; // Noticeable help
                } else if (playerMetrics.skillLevel === 'average' && playerMetrics.needsHelp) {
                    return 'subtle'; // Minor help
                } else {
                    return 'none'; // No help needed
                }
            },
            
            shouldIncreasePowerUpRate() {
                return playerMetrics.skillLevel === 'struggling' || 
                       (playerMetrics.consecutiveDeaths >= 2 && playerMetrics.currentAccuracy < 40);
            },
            
            shouldDecreasePowerUpRate() {
                return playerMetrics.skillLevel === 'skilled' && playerMetrics.currentAccuracy > 70;
            }
        };
        
        // Unified ball system
        const balls = []; // All balls in the game
        
        // Ball factory function
        function createBall(x, y, onPaddle = false) {
            return {
                x: x,
                y: y,
                radius: 8,
                dx: 0,
                dy: 0,
                speed: 5,
                normalSpeed: 5,
                onPaddle: onPaddle
            };
        }
        
        // Paddle Object
        const paddle = {
            x: 350,
            y: 550,
            width: 100,
            height: 15,
            speed: 8,
            normalWidth: 100,
            usingMouse: false,
            
            update() {
                // Arrow key controls (only if not using mouse)
                if (!this.usingMouse) {
                    if (game.keys['ArrowLeft'] && this.x > 0) {
                        this.x -= this.speed;
                    }
                    if (game.keys['ArrowRight'] && this.x < canvas.width - this.width) {
                        this.x += this.speed;
                    }
                }
                
                // Mouse controls (only when mouse is actively being used)
                if (this.usingMouse && game.mouse.x >= 0 && game.mouse.x <= canvas.width) {
                    this.x = Math.max(0, Math.min(canvas.width - this.width, game.mouse.x - this.width / 2));
                }
            },
            
            draw() {
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Add a slight gradient effect
                ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.fillRect(this.x, this.y, this.width, 3);
            },
            
            reset() {
                this.x = 350;
                this.width = this.normalWidth;
            }
        };
        
        // Unified ball update system
        function updateBalls() {
            // Update each ball
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                
                if (ball.onPaddle) {
                    // Ball follows paddle when on paddle
                    ball.x = paddle.x + paddle.width / 2;
                    ball.y = paddle.y - ball.radius;
                    continue;
                }
                
                // Move ball
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                // Wall collisions
                if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
                    ball.dx = -ball.dx;
                    ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
                    accessibility.announceWallBounce();
                }
                
                if (ball.y - ball.radius <= 0) {
                    ball.dy = -ball.dy;
                    ball.y = ball.radius;
                    accessibility.announceWallBounce();
                }
                
                // Paddle collision
                if (ball.y + ball.radius >= paddle.y && 
                    ball.y - ball.radius <= paddle.y + paddle.height &&
                    ball.x >= paddle.x && 
                    ball.x <= paddle.x + paddle.width) {
                    
                    // Calculate bounce angle based on where ball hits paddle
                    const hitPos = (ball.x - paddle.x) / paddle.width;
                    const bounceAngle = (hitPos - 0.5) * Math.PI * 0.6; // Max 54 degrees
                    
                    ball.dx = Math.sin(bounceAngle) * ball.speed;
                    ball.dy = -Math.cos(bounceAngle) * ball.speed;
                    ball.y = paddle.y - ball.radius;
                    
                    // Track paddle hits for AI
                    playerMetrics.paddleHits++;
                    playerMetrics.totalBallBounces++;
                    accessibility.announcePaddleHit();
                }
                
                // Remove balls that fall off bottom
                if (ball.y > canvas.height) {
                    balls.splice(i, 1);
                }
            }
            
            // If no balls left, respawn
            if (balls.length === 0) {
                respawn();
            }
        }
        
        function drawBalls() {
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                
                // Add glow effect
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }
        
        function launchBall() {
            // Launch the first ball on paddle
            const ballOnPaddle = balls.find(ball => ball.onPaddle);
            if (ballOnPaddle) {
                ballOnPaddle.onPaddle = false;
                ballOnPaddle.dx = (Math.random() - 0.5) * 4;
                ballOnPaddle.dy = -ballOnPaddle.speed;
            }
        }
        
        function respawn() {
            // Lose a life
            game.lives--;
            playerMetrics.ballsLost++;
            playerMetrics.consecutiveDeaths++;
            playerMetrics.missedBalls++;
            
            if (game.lives <= 0) {
                gameState = 'gameOver';
                accessibility.announceGameState('gameOver');
                // Show cursor when game ends
                canvas.classList.remove('playing');
                return;
            }
            
            // Brief pause before respawn
            gameState = 'ballLost';
            accessibility.announceGameState('ballLost');
            setTimeout(() => {
                if (game.lives > 0) {
                    // Add new ball on paddle
                    balls.push(createBall(paddle.x + paddle.width / 2, paddle.y - 8, true));
                    gameState = 'playing';
                }
            }, 1000);
        }
        
        function resetBalls() {
            balls.length = 0;
            balls.push(createBall(paddle.x + paddle.width / 2, paddle.y - 8, true));
        }
        
        // Sprint System Functions
        function initializeSprintControls() {
            // Set initial values from config
            document.getElementById('accelerationPeriod').value = sprintConfig.accelerationPeriodMs;
            document.getElementById('defaultSpeed').value = sprintConfig.defaultSpeed;
            document.getElementById('topSpeed').value = sprintConfig.topSpeed;
            
            // Add event listeners
            document.getElementById('applySprintConfig').addEventListener('click', applySprintSettings);
            document.getElementById('resetSprintConfig').addEventListener('click', resetSprintSettings);
        }
        
        function applySprintSettings() {
            sprintConfig.accelerationPeriodMs = parseInt(document.getElementById('accelerationPeriod').value);
            sprintConfig.defaultSpeed = parseFloat(document.getElementById('defaultSpeed').value);
            sprintConfig.topSpeed = parseFloat(document.getElementById('topSpeed').value);
            
            // Update existing balls if game is running
            updateExistingBallSpeeds();
            
            console.log('Sprint settings applied:', sprintConfig);
        }
        
        function resetSprintSettings() {
            sprintConfig.accelerationPeriodMs = 500;
            sprintConfig.defaultSpeed = 5;
            sprintConfig.topSpeed = 50;
            
            // Update UI
            initializeSprintControls();
            updateExistingBallSpeeds();
        }
        
        function updateExistingBallSpeeds() {
            // Update normalSpeed for existing balls based on new default speed
            balls.forEach(ball => {
                if (ball.normalSpeed === 5) { // Only update if it's still at default
                    ball.normalSpeed = sprintConfig.defaultSpeed;
                    if (!sprintState.isActive) {
                        ball.speed = ball.normalSpeed;
                    }
                }
            });
        }
        
        function handleSprintStart() {
            if (sprintState.isActive || gameState !== 'playing') return;
            
            sprintState.isActive = true;
            sprintState.isAccelerating = true;
            sprintState.isDecelerating = false;
            sprintState.startTime = performance.now();
            sprintState.ballStates.clear();
            
            // Record original speeds for all balls
            balls.forEach((ball, index) => {
                if (!ball.onPaddle) {
                    sprintState.ballStates.set(index, ball.speed);
                }
            });
            
            // Start acceleration audio
            startSprintAudio(true);
        }
        
        function handleSprintEnd() {
            if (!sprintState.isActive || sprintState.isDecelerating) return;
            
            sprintState.isAccelerating = false;
            sprintState.isDecelerating = true;
            sprintState.startTime = performance.now();
            
            // Start deceleration audio
            startSprintAudio(false);
        }
        
        function updateSprintSystem(deltaTime) {
            if (!sprintState.isActive) return;
            
            const currentTime = performance.now();
            const elapsed = currentTime - sprintState.startTime;
            const progress = Math.min(elapsed / sprintConfig.accelerationPeriodMs, 1);
            
            if (sprintState.isAccelerating) {
                // Accelerate all balls
                balls.forEach((ball, index) => {
                    if (!ball.onPaddle && sprintState.ballStates.has(index)) {
                        const originalSpeed = sprintState.ballStates.get(index);
                        const targetSpeed = originalSpeed * sprintConfig.speedMultiplier;
                        ball.speed = originalSpeed + (targetSpeed - originalSpeed) * progress;
                        
                        // Update velocity components proportionally
                        const speedRatio = ball.speed / originalSpeed;
                        ball.dx = (ball.dx / Math.abs(ball.dx || 1)) * Math.abs(ball.dx) * speedRatio;
                        ball.dy = (ball.dy / Math.abs(ball.dy || 1)) * Math.abs(ball.dy) * speedRatio;
                    }
                });
                
                if (progress >= 1) {
                    sprintState.isAccelerating = false;
                    // Continue at top speed
                }
            } else if (sprintState.isDecelerating) {
                // Decelerate all balls
                balls.forEach((ball, index) => {
                    if (!ball.onPaddle && sprintState.ballStates.has(index)) {
                        const originalSpeed = sprintState.ballStates.get(index);
                        const currentTopSpeed = originalSpeed * sprintConfig.speedMultiplier;
                        ball.speed = currentTopSpeed - (currentTopSpeed - originalSpeed) * progress;
                        
                        // Update velocity components proportionally
                        const speedRatio = ball.speed / currentTopSpeed;
                        ball.dx = (ball.dx / Math.abs(ball.dx || 1)) * Math.abs(ball.dx) * speedRatio;
                        ball.dy = (ball.dy / Math.abs(ball.dy || 1)) * Math.abs(ball.dy) * speedRatio;
                    }
                });
                
                if (progress >= 1) {
                    // Sprint complete
                    sprintState.isActive = false;
                    sprintState.isDecelerating = false;
                    sprintState.ballStates.clear();
                    stopSprintAudio();
                }
            }
        }
        
        function startSprintAudio(isAccelerating) {
            if (!accessibility.audioEnabled || !accessibility.audioContext) return;
            
            // Stop any existing sprint audio
            stopSprintAudio();
            
            // Create new oscillator
            sprintState.currentOscillator = accessibility.audioContext.createOscillator();
            const gainNode = accessibility.audioContext.createGain();
            
            sprintState.currentOscillator.connect(gainNode);
            gainNode.connect(accessibility.audioContext.destination);
            
            sprintState.currentOscillator.type = sprintAudio.oscillatorType;
            sprintState.currentOscillator.frequency.value = isAccelerating ? 
                sprintAudio.baseFrequency : sprintAudio.maxFrequency;
            
            gainNode.gain.setValueAtTime(sprintAudio.volume, accessibility.audioContext.currentTime);
            
            sprintState.currentOscillator.start();
            
            // Start audio update timer
            sprintState.audioUpdateTimer = setInterval(() => {
                updateSprintAudioPitch(isAccelerating);
            }, sprintAudio.updateInterval);
        }
        
        function updateSprintAudioPitch(isAccelerating) {
            if (!sprintState.currentOscillator || !sprintState.isActive) return;
            
            const currentTime = performance.now();
            const elapsed = currentTime - sprintState.startTime;
            const progress = Math.min(elapsed / sprintConfig.accelerationPeriodMs, 1);
            
            let frequency;
            if (isAccelerating) {
                frequency = sprintAudio.baseFrequency + 
                    (sprintAudio.maxFrequency - sprintAudio.baseFrequency) * progress;
            } else {
                frequency = sprintAudio.maxFrequency - 
                    (sprintAudio.maxFrequency - sprintAudio.baseFrequency) * progress;
            }
            
            sprintState.currentOscillator.frequency.setValueAtTime(
                frequency, 
                accessibility.audioContext.currentTime
            );
        }
        
        function stopSprintAudio() {
            if (sprintState.currentOscillator) {
                try {
                    sprintState.currentOscillator.stop();
                } catch (e) {
                    // Oscillator may already be stopped
                }
                sprintState.currentOscillator = null;
            }
            
            if (sprintState.audioUpdateTimer) {
                clearInterval(sprintState.audioUpdateTimer);
                sprintState.audioUpdateTimer = null;
            }
        }
        
        // Brick System
        const bricks = [];
        const brickConfig = {
            rows: 6,
            cols: 10,
            width: 75,
            height: 20,
            padding: 5,
            offsetTop: 60,
            offsetLeft: 37.5,
            types: [
                { color: '#ff4444', hits: 1, points: 10, name: 'red' },
                { color: '#ff8844', hits: 1, points: 20, name: 'orange' },
                { color: '#ffff44', hits: 2, points: 30, name: 'yellow' },
                { color: '#44ff44', hits: 2, points: 40, name: 'green' }
            ]
        };
        
        function createBricks() {
            bricks.length = 0;
            
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const x = col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft;
                    const y = row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop;
                    
                    // Determine brick type based on row
                    let typeIndex;
                    if (row < 2) typeIndex = 0; // Red bricks (top 2 rows)
                    else if (row < 4) typeIndex = 1; // Orange bricks (next 2 rows)
                    else if (row < 5) typeIndex = 2; // Yellow bricks (1 row)
                    else typeIndex = 3; // Green bricks (bottom row)
                    
                    const brickType = brickConfig.types[typeIndex];
                    
                    bricks.push({
                        x: x,
                        y: y,
                        width: brickConfig.width,
                        height: brickConfig.height,
                        hits: brickType.hits,
                        maxHits: brickType.hits,
                        points: brickType.points,
                        color: brickType.color,
                        name: brickType.name,
                        destroyed: false
                    });
                }
            }
        }
        
        function drawBricks() {
            bricks.forEach(brick => {
                if (brick.destroyed) return;
                
                // Calculate color intensity based on remaining hits
                const intensity = brick.hits / brick.maxHits;
                let color = brick.color;
                
                if (intensity < 1) {
                    // Darken damaged bricks
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);
                    
                    color = `rgb(${Math.floor(r * intensity)}, ${Math.floor(g * intensity)}, ${Math.floor(b * intensity)})`;
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                
                // Add border
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                
                // Add highlight for 3D effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(brick.x, brick.y, brick.width, 3);
            });
        }
        
        // Power-up System
        const powerUps = [];
        const activePowerUps = [];
        
        const powerUpTypes = {
            widePaddle: {
                name: 'Wide Paddle',
                color: '#4444ff',
                letter: 'W',
                duration: 15000,
                effect: () => {
                    paddle.width = paddle.normalWidth * 1.5;
                },
                reset: () => {
                    paddle.width = paddle.normalWidth;
                }
            },
            multiBall: {
                name: 'Multi-ball',
                color: '#ff44ff',
                letter: 'M',
                duration: 0, // Permanent until balls are lost
                effect: () => {
                    // Find a ball that's not on paddle to split
                    const activeBall = balls.find(b => !b.onPaddle);
                    if (activeBall) {
                        const originalDx = activeBall.dx;
                        const originalDy = activeBall.dy;
                        
                        // Create two additional balls
                        balls.push(createBall(activeBall.x, activeBall.y, false));
                        const newBall1 = balls[balls.length - 1];
                        newBall1.dx = originalDx * 0.7 + 2;
                        newBall1.dy = originalDy;
                        newBall1.speed = activeBall.speed;
                        
                        balls.push(createBall(activeBall.x, activeBall.y, false));
                        const newBall2 = balls[balls.length - 1];
                        newBall2.dx = originalDx * 0.7 - 2;
                        newBall2.dy = originalDy;
                        newBall2.speed = activeBall.speed;
                        
                        // Modify original ball
                        activeBall.dx = originalDx;
                        activeBall.dy = originalDy;
                    }
                }
            },
            slowBall: {
                name: 'Slow Ball',
                color: '#44ff44',
                letter: 'S',
                duration: 20000,
                effect: () => {
                    balls.forEach(b => {
                        b.speed = b.normalSpeed * 0.7;
                    });
                },
                reset: () => {
                    balls.forEach(b => {
                        b.speed = b.normalSpeed;
                    });
                }
            }
        };
        
        function createPowerUp(x, y) {
            const types = Object.keys(powerUpTypes);
            const randomType = types[Math.floor(Math.random() * types.length)];
            
            powerUps.push({
                x: x - 15,
                y: y,
                width: 30,
                height: 20,
                dy: 2,
                type: randomType,
                config: powerUpTypes[randomType]
            });
        }
        
        
        function checkBrickCollisionsForBall(ballObj) {
            for (let i = 0; i < bricks.length; i++) {
                const brick = bricks[i];
                if (brick.destroyed) continue;
                
                if (ballObj.x + ballObj.radius > brick.x &&
                    ballObj.x - ballObj.radius < brick.x + brick.width &&
                    ballObj.y + ballObj.radius > brick.y &&
                    ballObj.y - ballObj.radius < brick.y + brick.height) {
                    
                    const ballCenterX = ballObj.x;
                    const ballCenterY = ballObj.y;
                    const brickCenterX = brick.x + brick.width / 2;
                    const brickCenterY = brick.y + brick.height / 2;
                    
                    const deltaX = ballCenterX - brickCenterX;
                    const deltaY = ballCenterY - brickCenterY;
                    
                    const intersectX = Math.abs(deltaX) - (brick.width / 2 + ballObj.radius);
                    const intersectY = Math.abs(deltaY) - (brick.height / 2 + ballObj.radius);
                    
                    if (intersectX > intersectY) {
                        ballObj.dx = -ballObj.dx;
                    } else {
                        ballObj.dy = -ballObj.dy;
                    }
                    
                    brick.hits--;
                    playerMetrics.bricksHit++;
                    playerMetrics.totalBallBounces++;
                    
                    if (brick.hits <= 0) {
                        brick.destroyed = true;
                        game.score += brick.points;
                        
                        createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color);
                        accessibility.announceBrickHit(brick.name, brick.points);
                        
                        // Dynamic power-up drop rate based on player performance
                        let dropRate = 0.15; // Base 15% chance
                        
                        if (aiAnalysis.shouldIncreasePowerUpRate()) {
                            dropRate = 0.25; // 25% for struggling players
                        } else if (aiAnalysis.shouldDecreasePowerUpRate()) {
                            dropRate = 0.10; // 10% for skilled players
                        }
                        
                        if (Math.random() < dropRate) {
                            createPowerUp(brick.x + brick.width / 2, brick.y + brick.height / 2);
                        }
                        
                        playerMetrics.consecutiveDeaths = 0;
                    }
                    
                    if (bricks.every(b => b.destroyed)) {
                        gameState = 'levelComplete';
                        accessibility.announceGameState('levelComplete');
                        setTimeout(() => {
                            nextLevel();
                        }, 2000);
                    }
                    
                    break;
                }
            }
        }
        
        // Particle System for Visual Effects
        const particles = [];
        
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    color: color,
                    life: 30,
                    maxLife: 30
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.dy += 0.3; // Gravity
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
            });
        }
        
        function updatePowerUps() {
            // Update falling power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.dy;
                
                // Check collision with paddle
                if (powerUp.y + powerUp.height >= paddle.y &&
                    powerUp.y <= paddle.y + paddle.height &&
                    powerUp.x + powerUp.width >= paddle.x &&
                    powerUp.x <= paddle.x + paddle.width) {
                    
                    // Activate power-up
                    activatePowerUp(powerUp.type);
                    powerUps.splice(i, 1);
                    continue;
                }
                
                // Remove if off screen
                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                }
            }
            
            // Update active power-up timers
            for (let i = activePowerUps.length - 1; i >= 0; i--) {
                const activePowerUp = activePowerUps[i];
                activePowerUp.timeLeft -= 16; // Approximate frame time
                
                if (activePowerUp.timeLeft <= 0) {
                    // Reset power-up effect
                    if (activePowerUp.config.reset) {
                        activePowerUp.config.reset();
                    }
                    activePowerUps.splice(i, 1);
                }
            }
        }
        
        function drawPowerUps() {
            // Draw falling power-ups
            powerUps.forEach(powerUp => {
                // Draw power-up background with better contrast
                ctx.fillStyle = powerUp.config.color;
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                
                // Add dark border for better definition
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                
                // Draw letter with text shadow for better contrast
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                // Text shadow
                ctx.fillText(powerUp.config.letter, powerUp.x + powerUp.width / 2 + 1, powerUp.y + 15);
                
                // Main text in white
                ctx.fillStyle = '#fff';
                ctx.fillText(powerUp.config.letter, powerUp.x + powerUp.width / 2, powerUp.y + 14);
            });
        }
        
        function activatePowerUp(type) {
            const config = powerUpTypes[type];
            
            // Apply effect
            config.effect();
            accessibility.announcePowerUp(config.name);
            
            // Add to active power-ups if it has a duration
            if (config.duration > 0) {
                // Remove existing power-up of same type
                for (let i = activePowerUps.length - 1; i >= 0; i--) {
                    if (activePowerUps[i].type === type) {
                        activePowerUps.splice(i, 1);
                        break;
                    }
                }
                
                activePowerUps.push({
                    type: type,
                    config: config,
                    timeLeft: config.duration
                });
            }
            
            updatePowerUpUI();
        }
        
        function updatePowerUpUI() {
            const powerUpDiv = document.getElementById('powerUps');
            powerUpDiv.innerHTML = '';
            
            activePowerUps.forEach(powerUp => {
                const timer = document.createElement('div');
                timer.className = 'power-up-timer';
                timer.style.backgroundColor = powerUp.config.color;
                timer.textContent = `${powerUp.config.name}: ${Math.ceil(powerUp.timeLeft / 1000)}s`;
                powerUpDiv.appendChild(timer);
            });
        }
        
        
        function nextLevel() {
            game.level++;
            createBricks();
            paddle.reset();
            resetBalls();
            
            // Slightly increase difficulty each level
            balls.forEach(ball => {
                ball.normalSpeed += 0.2;
                ball.speed = ball.normalSpeed;
            });
            
            // Increase paddle speed slightly too
            paddle.speed += 0.2;
            
            gameState = 'playing';
            playerMetrics.levelStartTime = Date.now();
            
            // Reset consecutive deaths for new level
            playerMetrics.consecutiveDeaths = 0;
        }
        
        // Event Listeners
        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
            
            // Switch to keyboard control when arrow keys are pressed
            if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                paddle.usingMouse = false;
            }
            
            // ENTER key launches ball when using keyboard controls
            if (e.code === 'Enter' && gameState === 'playing' && !paddle.usingMouse) {
                e.preventDefault();
                launchBall();
            }
            
            // SHIFT key starts sprint
            if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && gameState === 'playing') {
                e.preventDefault();
                handleSprintStart();
            }
            
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'playing') {
                    gameState = 'paused';
                    accessibility.announceGameState('paused');
                } else if (gameState === 'paused') {
                    gameState = 'playing';
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
            
            // SHIFT key ends sprint
            if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && gameState === 'playing') {
                e.preventDefault();
                handleSprintEnd();
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouse.x = e.clientX - rect.left;
            game.mouse.y = e.clientY - rect.top;
            
            // Switch to mouse control when mouse moves
            if (gameState === 'playing') {
                paddle.usingMouse = true;
            }
        });
        
        canvas.addEventListener('click', (e) => {
            if (gameState === 'menu' || gameState === 'gameOver') {
                startGame();
            } else if (gameState === 'playing') {
                launchBall();
            } else if (gameState === 'ballLost') {
                // Allow clicking during ball lost state to continue faster
                if (game.lives > 0) {
                    balls.push(createBall(paddle.x + paddle.width / 2, paddle.y - 8, true));
                    gameState = 'playing';
                }
            }
        });
        
        // Game Functions
        function startGame() {
            gameState = 'playing';
            game.score = 0;
            game.lives = 3;
            game.level = 1;
            
            // Hide cursor when game starts
            canvas.classList.add('playing');
            
            // Reset objects to initial state
            paddle.reset();
            paddle.speed = 8; // Reset paddle speed
            createBricks();
            resetBalls();
            
            // Clear particles and power-ups
            particles.length = 0;
            powerUps.length = 0;
            activePowerUps.length = 0;
            updatePowerUpUI();
            
            // Reset metrics
            Object.keys(playerMetrics).forEach(key => {
                if (key !== 'levelStartTime' && key !== 'recentPerformance') {
                    if (key === 'skillLevel') {
                        playerMetrics[key] = 'average';
                    } else if (key === 'needsHelp') {
                        playerMetrics[key] = false;
                    } else {
                        playerMetrics[key] = 0;
                    }
                }
            });
            playerMetrics.levelStartTime = Date.now();
            playerMetrics.recentPerformance = [];
            aiAnalysis.lastUpdate = Date.now();
            
            accessibility.announceGameState('playing');
            updateUI();
        }
        
        function updateUI() {
            document.getElementById('score').textContent = game.score;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('level').textContent = game.level;
            
            // Calculate and display accuracy with AI skill level indicator
            const accuracy = playerMetrics.totalBallBounces > 0 ? 
                Math.round((playerMetrics.bricksHit / playerMetrics.totalBallBounces) * 100) : 0;
            
            let accuracyText = accuracy + '%';
            
            // Add skill level indicator (subtle visual feedback)
            if (playerMetrics.skillLevel === 'struggling') {
                accuracyText += ' üî¥'; // Red circle for struggling
            } else if (playerMetrics.skillLevel === 'skilled') {
                accuracyText += ' üü¢'; // Green circle for skilled
            } else {
                accuracyText += ' üü°'; // Yellow circle for average
            }
            
            document.getElementById('accuracy').textContent = accuracyText;
            playerMetrics.currentAccuracy = accuracy;
        }
        
        function drawMenu() {
            // Show cursor in menu
            canvas.classList.remove('playing');
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BRICK BALL', canvas.width / 2, 200);
            
            ctx.font = '24px Arial';
            ctx.fillText('Intelligent Adaptive Gameplay', canvas.width / 2, 240);
            
            ctx.font = '18px Arial';
            ctx.fillText('Click to Start', canvas.width / 2, 350);
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText('The AI will adapt to help you succeed!', canvas.width / 2, 400);
        }
        
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, 200);
            
            ctx.font = '24px Arial';
            ctx.fillText(`Final Score: ${game.score}`, canvas.width / 2, 260);
            ctx.fillText(`Level Reached: ${game.level}`, canvas.width / 2, 290);
            ctx.fillText(`Accuracy: ${playerMetrics.currentAccuracy}%`, canvas.width / 2, 320);
            
            ctx.font = '16px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText(`Bricks Hit: ${playerMetrics.bricksHit} | Balls Lost: ${playerMetrics.ballsLost}`, canvas.width / 2, 360);
            
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            ctx.fillText('Click to Play Again', canvas.width / 2, 420);
        }
        
        function drawBallLost() {
            // Draw game objects (frozen)
            drawBricks();
            paddle.draw();
            drawParticles();
            
            // Draw ball lost message
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ff4444';
            ctx.font = '36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BALL LOST!', canvas.width / 2, canvas.height / 2 - 20);
            
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            ctx.fillText(`Lives Remaining: ${game.lives}`, canvas.width / 2, canvas.height / 2 + 20);
            
            if (game.lives > 0) {
                ctx.font = '14px Arial';
                ctx.fillStyle = '#aaa';
                ctx.fillText('Click to continue or wait...', canvas.width / 2, canvas.height / 2 + 50);
            }
        }
        
        function drawPaused() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            
            ctx.font = '18px Arial';
            ctx.fillText('Press SPACE to continue', canvas.width / 2, canvas.height / 2 + 40);
        }
        
        // Main Game Loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - game.lastTime;
            game.lastTime = currentTime;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'playing') {
                // Update game objects
                paddle.update();
                updateBalls();
                updatePowerUps();
                updateParticles();
                
                // Check brick collisions for all balls
                balls.forEach(ball => checkBrickCollisionsForBall(ball));
                
                // Draw game objects
                drawBricks();
                paddle.draw();
                drawBalls();
                drawPowerUps();
                drawParticles();
                
                // Update AI analysis
                if (Date.now() - aiAnalysis.lastUpdate > aiAnalysis.updateInterval) {
                    aiAnalysis.analyzePerformance();
                    aiAnalysis.lastUpdate = Date.now();
                }
                
                // Update UI
                updateUI();
                
            } else if (gameState === 'levelComplete') {
                // Draw game objects
                drawBricks();
                paddle.draw();
                drawBalls();
                drawParticles();
                
                // Draw level complete message
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2);
                
                ctx.font = '18px Arial';
                ctx.fillText('Get ready for the next level...', canvas.width / 2, canvas.height / 2 + 40);
                
            } else if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'gameOver') {
                drawGameOver();
            } else if (gameState === 'ballLost') {
                drawBallLost();
            } else if (gameState === 'paused') {
                // Draw game objects (frozen)
                drawBricks();
                paddle.draw();
                drawBalls();
                drawPowerUps();
                drawParticles();
                drawPaused();
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // Initialize accessibility system
        accessibility.init();
        
        // Announce initial menu state
        accessibility.announceGameState('menu');
        
        // Start the game
        gameLoop(0);
    </script>
</body>
</html>
